## JSX

JSX 标签语法既不是字符串也不是 HTML。

### 大括号 {}

在大括号中，可以放入任何 JavaScript 表达式。

```react
const name = 'Josh Perez';
const element = <h1>Hello, {name}</h1>;

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);
```

使用 () 包裹 JSX，可以避免自动插入分号。

编译之后，JSX 表达式会被转为普通的 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。可以在代码块中使用 JSX，可以将 JSX 赋值给变量，也可以把 JSX 作为参数传入，以及从函数中返回 JSX。

### JSX 中指定属性

使用**引号**，将属性值指定为**字符串字面量**：

```react
const element = <a href="https://www.reactjs.org"> link </a>;
```

使用**大括号 {}**，在属性值中插入一个 **JavaScript 表达式**：

```react
const element = <img src={user.avatarUrl}></img>;
```

因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 `camelCase`（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。

例如，JSX 里的 `class` 变成了 `className`，而 `tabindex` 则变为 `tabIndex`。

### JSX 防止注入攻击（XSS）

React DOM 在渲染所有输入内容之前，默认会进行转义，可以有效地防止 XSS 攻击。

### JSX 表示对象

Babel 会把 JSX 转译成一个名为 `React.createElement()` 函数调用。

以下两种示例代码完全等效：

```react
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```

## 元素渲染

React 元素是创建开销极小的普通对象。React 元素是**不可变对象**。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。更新 UI 唯一的方式是创建一个全新的元素，并将其传入 `root.render()`。

## 组件 & Props

组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。

### 函数组件与 class 组件

```react
/** 函数组件
	该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。
*/
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

/** class 组件 */
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

**所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。**

## State & 生命周期

 state 是私有的，并且完全受控于当前组件。

每次组件更新时 `render` 方法都会被调用，但只要在相同的 DOM 节点中渲染 `<Clock />` ，就仅有一个 `Clock` 组件的 class 实例被创建使用。

### 正确地使用 State

- **不要直接修改 State**。构造函数是唯一可以给 `this.state` 赋值的地方。

  ```react
  // Wrong
  this.state.comment = 'Hello';
  // Correct
  this.setState({comment: 'Hello'});
  ```

- **State 的更新可能是异步的**。出于性能考虑，React 可能会把多个 `setState()` 调用合并成一个调用。

  ```react
  // Wrong
  this.setState({
    counter: this.state.counter + this.props.increment,
  });
  // Correct
  this.setState((state, props) => ({
    counter: state.counter + props.increment
  }));
  ```

  可以让 `setState()` 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数。

- **State 的更新会被合并**。调用 `setState()` 的时候，React 会把你提供的对象合并到当前的 state。

## 事件处理

- React 事件的命名采用小驼峰式（camelCase），而不是纯小写。
- 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。

```react
// HTML
<button onclick="activateLasers()">
  Activate Lasers
</button>

// React
<button onClick={activateLasers}>  
  Activate Lasers
</button>
```

### 阻止事件默认行为

在 React 中，你不能通过返回 `false` 的方式阻止默认行为。你必须显式地使用 `preventDefault`。

```react
function Form() {
  function handleSubmit(e) {
    e.preventDefault();    
    console.log('You clicked submit.');
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  );
}
```

在这里，`e` 是一个合成事件。React 根据 [W3C 规范](https://www.w3.org/TR/DOM-Level-3-Events/)来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。